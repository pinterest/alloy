// Vitest Snapshot v1, https://vitest.dev/guide/snapshot.html

exports[`Thrift snapshots > renders ThriftTest.thrift 1`] = `
{
  "ThriftTest.thrift": "namespace c_glib TTest
namespace cpp thrift.test
namespace delphi Thrift.Test
namespace go thrifttest
namespace java thrift.test
namespace js ThriftTest
namespace lua ThriftTest
namespace netstd ThriftTest
namespace perl ThriftTest
namespace php ThriftTest
namespace py ThriftTest
namespace py.twisted ThriftTest
namespace rb Thrift.Test
namespace st ThriftTest
namespace noexist ThriftTest
namespace cpp.noexist ThriftTest

enum Numberz {
  ONE = 1,
  TWO,
  THREE,
  FIVE = 5,
  SIX,
  EIGHT = 8
}

typedef i64 UserId

typedef map<string, Bonk> MapType

const Numberz myNumberz = 1

struct Bonk {
  1: string message;
  2: i32 type;
}

struct Bools {
  1: bool im_true;
  2: bool im_false;
}

struct Xtruct {
  1: string string_thing;
  4: i8 byte_thing;
  9: i32 i32_thing;
  11: i64 i64_thing;
}

struct Xtruct2 {
  1: i8 byte_thing;
  2: Xtruct struct_thing;
  3: i32 i32_thing;
}

struct Xtruct3 {
  1: string string_thing;
  4: i32 changed;
  9: i32 i32_thing;
  11: i64 i64_thing;
}

struct Insanity {
  1: map<Numberz, UserId> userMap;
  2: list<Xtruct> xtructs;
}

struct CrazyNesting {
  1: string string_field;
  2: optional set<Insanity> set_field;
  3: required list<map<set<i32> (python.immutable=""), map<i32, set<list<map<Insanity, string> (python.immutable="")> (python.immutable="")>>>> list_field;
  4: binary binary_field;
  5: uuid uuid_field;
}

struct EmptyStruct {}

struct OneField {
  1: EmptyStruct field;
}

struct VersioningTestV1 {
  1: i32 begin_in_both;
  3: string old_string;
  12: i32 end_in_both;
}

struct VersioningTestV2 {
  1: i32 begin_in_both;
  2: i32 newint;
  3: i8 newbyte;
  4: i16 newshort;
  5: i64 newlong;
  6: double newdouble;
  7: Bonk newstruct;
  8: list<i32> newlist;
  9: set<i32> newset;
  10: map<i32, i32> newmap;
  11: string newstring;
  12: i32 end_in_both;
}

struct ListTypeVersioningV1 {
  1: list<i32> myints;
  2: string hello;
}

struct ListTypeVersioningV2 {
  1: list<string> strings;
  2: string hello;
}

struct GuessProtocolStruct {
  7: map<string, string> map_field;
}

struct LargeDeltas {
  1: Bools b1;
  10: Bools b10;
  100: Bools b100;
  500: bool check_true;
  1000: Bools b1000;
  1500: bool check_false;
  2000: VersioningTestV2 vertwo2000;
  2500: set<string> a_set2500;
  3000: VersioningTestV2 vertwo3000;
  4000: list<i32> big_numbers;
}

struct NestedListsI32x2 {
  1: list<list<i32>> integerlist;
}

struct NestedListsI32x3 {
  1: list<list<list<i32>>> integerlist;
}

struct NestedMixedx2 {
  1: list<set<i32>> int_set_list;
  2: map<i32, set<string>> map_int_strset;
  3: list<map<i32, set<string>>> map_int_strset_list;
}

struct ListBonks {
  1: list<Bonk> bonk;
}

struct NestedListsBonk {
  1: list<list<list<Bonk>>> bonk;
}

struct BoolTest {
  1: optional bool b = true;
  2: optional string s = "true";
}

struct StructA {
  1: required string s;
}

struct StructB {
  1: optional StructA aa;
  2: required StructA ab;
}

struct OptionalSetDefaultTest {
  1: optional set<string> with_default = [ "test" ];
}

struct OptionalBinary {
  1: optional set<binary> bin_set = {  };
  2: optional map<binary, i32> bin_map = {  };
}

union SomeUnion {
  1: optional map<Numberz, UserId> map_thing;
  2: optional string string_thing;
  3: optional i32 i32_thing;
  4: optional Xtruct3 xtruct_thing;
  5: optional Insanity insanity_thing;
}

exception Xception {
  1: i32 errorCode;
  2: string message;
}

exception Xception2 {
  1: i32 errorCode;
  2: Xtruct struct_thing;
}

service ThriftTest {
  void testVoid();
  string testString(1: string thing);
  bool testBool(1: bool thing);
  i8 testByte(1: i8 thing);
  i32 testI32(1: i32 thing);
  i64 testI64(1: i64 thing);
  double testDouble(1: double thing);
  binary testBinary(1: binary thing);
  uuid testUuid(1: uuid thing);
  Xtruct testStruct(1: Xtruct thing);
  Xtruct2 testNest(1: Xtruct2 thing);
  map<i32, i32> testMap(1: map<i32, i32> thing);
  map<string, string> testStringMap(1: map<string, string> thing);
  set<i32> testSet(1: set<i32> thing);
  list<i32> testList(1: list<i32> thing);
  Numberz testEnum(1: Numberz thing);
  UserId testTypedef(1: UserId thing);
  map<i32, map<i32, i32>> testMapMap(1: i32 hello);
  map<UserId, map<Numberz, Insanity>> testInsanity(1: Insanity argument);
  Xtruct testMulti(1: i8 arg0,
  2: i32 arg1,
  3: i64 arg2,
  4: map<i16, string> arg3,
  5: Numberz arg4,
  6: UserId arg5);
  void testException(1: string arg) throws (1: Xception err1);
  Xtruct testMultiException(1: string arg0,
  2: string arg1) throws (1: Xception err1,
  2: Xception2 err2);
  oneway void testOneway(1: i32 secondsToSleep);
}

service SecondService {
  string secondtestString(1: string thing);
}",
}
`;
